From 1e1bcb3090748f1c35708e80935c6b4bc4c54354 Mon Sep 17 00:00:00 2001
From: Julien Massot <julien.massot@iot.bzh>
Date: Wed, 23 Sep 2020 14:28:56 +0200
Subject: [PATCH 12/16] clk: add clock for MFIS registers

---
 drivers/clk/renesas/r8a7795-cpg-mssr.c  | 1 +
 drivers/clk/renesas/r8a77990-cpg-mssr.c | 2 ++
 2 files changed, 3 insertions(+)

diff --git a/drivers/clk/renesas/r8a7795-cpg-mssr.c b/drivers/clk/renesas/r8a7795-cpg-mssr.c
index bbfe54dffc7c..a46e027b4535 100644
--- a/drivers/clk/renesas/r8a7795-cpg-mssr.c
+++ b/drivers/clk/renesas/r8a7795-cpg-mssr.c
@@ -137,6 +137,7 @@ static struct mssr_mod_clk r8a7795_mod_clks[] __initdata = {
 	DEF_MOD("msiof2",		 209,	R8A7795_CLK_MSO),
 	DEF_MOD("msiof1",		 210,	R8A7795_CLK_MSO),
 	DEF_MOD("msiof0",		 211,	R8A7795_CLK_MSO),
+	DEF_MOD("mfis",		         213,	R8A7795_CLK_MSO),
 	DEF_MOD("sys-dmac2",		 217,	R8A7795_CLK_S3D1),
 	DEF_MOD("sys-dmac1",		 218,	R8A7795_CLK_S3D1),
 	DEF_MOD("sys-dmac0",		 219,	R8A7795_CLK_S0D3),
diff --git a/drivers/clk/renesas/r8a77990-cpg-mssr.c b/drivers/clk/renesas/r8a77990-cpg-mssr.c
index 4e0671f81d7b..afabd22aa4fd 100644
--- a/drivers/clk/renesas/r8a77990-cpg-mssr.c
+++ b/drivers/clk/renesas/r8a77990-cpg-mssr.c
@@ -138,6 +138,8 @@ static const struct mssr_mod_clk r8a77990_mod_clks[] __initconst = {
 	DEF_MOD("msiof2",		 209,	R8A77990_CLK_MSO),
 	DEF_MOD("msiof1",		 210,	R8A77990_CLK_MSO),
 	DEF_MOD("msiof0",		 211,	R8A77990_CLK_MSO),
+	/* FIXME: parent clock 'MS0' looks wrong */
+	DEF_MOD("mfis",		         213,	R8A77990_CLK_MSO),
 	DEF_MOD("sys-dmac2",		 217,	R8A77990_CLK_S3D1),
 	DEF_MOD("sys-dmac1",		 218,	R8A77990_CLK_S3D1),
 	DEF_MOD("sys-dmac0",		 219,	R8A77990_CLK_S3D1),
-- 
2.26.2


From 61a7eb99263a4cca3fd75d2142b509625da25356 Mon Sep 17 00:00:00 2001
From: Julien Massot <julien.massot@iot.bzh>
Date: Mon, 26 Oct 2020 10:46:18 +0100
Subject: [PATCH 13/16] add mailbox driver

---
 drivers/mailbox/Kconfig     |   8 ++
 drivers/mailbox/Makefile    |   2 +
 drivers/mailbox/rcar-ipcc.c | 236 ++++++++++++++++++++++++++++++++++++
 3 files changed, 246 insertions(+)
 create mode 100644 drivers/mailbox/rcar-ipcc.c

diff --git a/drivers/mailbox/Kconfig b/drivers/mailbox/Kconfig
index ab4eb750bbdd..79ccd0288518 100644
--- a/drivers/mailbox/Kconfig
+++ b/drivers/mailbox/Kconfig
@@ -199,6 +199,14 @@ config BCM_FLEXRM_MBOX
 	  which provides access to various offload engines on Broadcom
 	  SoCs. Say Y here if you want to use the Broadcom FlexRM.
 
+config RCAR_IPCC
+	tristate "Renesas R-Car IPCC Mailbox"
+	depends on ARCH_RENESAS
+	help
+	  Mailbox implementation for Renesas R-Car family chips
+	  with hardware for Inter-Processor Communication Controller (IPCC)
+	  between processors. Say Y here if you want to have this support.
+
 config STM32_IPCC
 	tristate "STM32 IPCC Mailbox"
 	depends on MACH_STM32MP157
diff --git a/drivers/mailbox/Makefile b/drivers/mailbox/Makefile
index c22fad6f696b..fe2594cbb05e 100644
--- a/drivers/mailbox/Makefile
+++ b/drivers/mailbox/Makefile
@@ -43,6 +43,8 @@ obj-$(CONFIG_QCOM_APCS_IPC)	+= qcom-apcs-ipc-mailbox.o
 
 obj-$(CONFIG_TEGRA_HSP_MBOX)	+= tegra-hsp.o
 
+obj-$(CONFIG_RCAR_IPCC) 	+= rcar-ipcc.o
+
 obj-$(CONFIG_STM32_IPCC) 	+= stm32-ipcc.o
 
 obj-$(CONFIG_MTK_CMDQ_MBOX)	+= mtk-cmdq-mailbox.o
diff --git a/drivers/mailbox/rcar-ipcc.c b/drivers/mailbox/rcar-ipcc.c
new file mode 100644
index 000000000000..73518cd00e9a
--- /dev/null
+++ b/drivers/mailbox/rcar-ipcc.c
@@ -0,0 +1,236 @@
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/mailbox_controller.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+/* From AP processor to realtime processor */
+#define MFISARIICR0 0x0 /* tx */
+#define MFISARIICR1 0x8 /* rxdone */
+/* From AP realtime to AP processor */
+#define MFISAREICR0 0x4 /* txdone */
+#define MFISAREICR1 0xc /* rx */
+
+#define INT_BIT BIT(0)
+#define TX_BIT BIT(1)
+
+enum {
+	IPCC_IRQ_RX,
+	IPCC_IRQ_TX,
+	IPCC_IRQ_NUM,
+};
+
+struct rcar_ipcc {
+	struct mbox_controller controller;
+	void __iomem *reg_base;
+	struct clk *clk;
+	spinlock_t lock; /* protect access to IPCC registers */
+	int irqs[IPCC_IRQ_NUM];
+};
+
+static inline void rcar_ipcc_set_bits(spinlock_t *lock, void __iomem *reg,
+				       u32 mask)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(lock, flags);
+	writel_relaxed(readl_relaxed(reg) | mask, reg);
+	spin_unlock_irqrestore(lock, flags);
+}
+
+static inline void rcar_ipcc_clr_bits(spinlock_t *lock, void __iomem *reg,
+				       u32 mask)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(lock, flags);
+	writel_relaxed(readl_relaxed(reg) & ~mask, reg);
+	spin_unlock_irqrestore(lock, flags);
+}
+
+static irqreturn_t rcar_ipcc_rx_irq(int irq, void *data)
+{
+	struct rcar_ipcc *ipcc = data;
+	uint32_t status, chan = 1;
+	irqreturn_t ret = IRQ_NONE;
+
+	/* clear irq */
+	rcar_ipcc_clr_bits(&ipcc->lock, ipcc->reg_base + MFISAREICR1, INT_BIT);
+	
+	status = readl_relaxed(ipcc->reg_base + MFISAREICR1);
+	if (status & TX_BIT) {
+		mbox_chan_received_data(&ipcc->controller.chans[chan], NULL);
+		
+		/* raise irq on remoteproc rx done */
+		rcar_ipcc_set_bits(&ipcc->lock, ipcc->reg_base + MFISARIICR1,
+				   INT_BIT);
+		ret = IRQ_HANDLED;
+	}
+	return ret;
+}
+
+static irqreturn_t rcar_ipcc_tx_irq(int irq, void *data)
+{
+	struct rcar_ipcc *ipcc = data;
+	irqreturn_t ret = IRQ_NONE;
+
+	uint32_t chan = 0;
+	uint32_t status;
+	/* clear irq */
+	rcar_ipcc_clr_bits(&ipcc->lock, ipcc->reg_base + MFISAREICR0, INT_BIT);
+	
+	status = readl_relaxed(ipcc->reg_base + MFISARIICR0);
+	if (status & TX_BIT) {
+		rcar_ipcc_clr_bits(&ipcc->lock, ipcc->reg_base + MFISARIICR0, TX_BIT);
+		mbox_chan_txdone(&ipcc->controller.chans[chan], 0);
+		ret = IRQ_HANDLED;
+	}
+	return ret;
+}
+
+static int rcar_ipcc_send_data(struct mbox_chan *link, void *data)
+{
+	struct rcar_ipcc *ipcc = container_of(link->mbox, struct rcar_ipcc,
+					       controller);
+	uint32_t status;
+
+	status = readl_relaxed(ipcc->reg_base + MFISARIICR0);
+	if (status & TX_BIT) {
+		dev_err(ipcc->controller.dev, "ERROR tx channel is busy !");
+		return -EBUSY;
+	}
+
+	/* set channel occupied, and raise irq on remoteproc */
+	rcar_ipcc_set_bits(&ipcc->lock, ipcc->reg_base + MFISARIICR0,
+				TX_BIT|INT_BIT);
+	return 0;
+}
+
+static int rcar_ipcc_startup(struct mbox_chan *link)
+{
+	struct rcar_ipcc *ipcc = container_of(link->mbox, struct rcar_ipcc,
+					       controller);
+	int ret;
+
+	ret = clk_prepare_enable(ipcc->clk);
+	if (ret) {
+		dev_err(ipcc->controller.dev, "can not enable the clock\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void rcar_ipcc_shutdown(struct mbox_chan *link)
+{
+	struct rcar_ipcc *ipcc = container_of(link->mbox, struct rcar_ipcc,
+					       controller);
+
+	clk_disable_unprepare(ipcc->clk);
+}
+
+static const struct mbox_chan_ops rcar_ipcc_ops = {
+	.send_data	= rcar_ipcc_send_data,
+	.startup	= rcar_ipcc_startup,
+	.shutdown	= rcar_ipcc_shutdown,
+};
+
+static int rcar_ipcc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct rcar_ipcc *ipcc;
+	struct resource *res;
+	static const char * const irq_name[] = {"rx", "tx"};
+	irq_handler_t irq_thread[] = {rcar_ipcc_rx_irq, rcar_ipcc_tx_irq};
+	int ret;
+	unsigned int i;
+
+	if (!np) {
+		dev_err(dev, "No DT found\n");
+		return -ENODEV;
+	}
+
+	ipcc = devm_kzalloc(dev, sizeof(*ipcc), GFP_KERNEL);
+	if (!ipcc)
+		return -ENOMEM;
+
+	spin_lock_init(&ipcc->lock);
+	
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ipcc->reg_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(ipcc->reg_base))
+		return PTR_ERR(ipcc->reg_base);
+
+	/* clock */
+	ipcc->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(ipcc->clk))
+		return PTR_ERR(ipcc->clk);
+
+	/* irq */
+	for (i = 0; i < IPCC_IRQ_NUM; i++) {
+		ipcc->irqs[i] = platform_get_irq_byname(pdev, irq_name[i]);
+		if (ipcc->irqs[i] < 0) {
+			if (ipcc->irqs[i] != -EPROBE_DEFER)
+				dev_err(dev, "no IRQ specified %s\n",
+					irq_name[i]);
+			ret = ipcc->irqs[i];
+			goto err_clk;
+		}
+
+		ret = devm_request_threaded_irq(dev, ipcc->irqs[i], NULL,
+						irq_thread[i], IRQF_ONESHOT,
+						dev_name(dev), ipcc);
+		if (ret) {
+			dev_err(dev, "failed to request irq %d (%d)\n", i, ret);
+			goto err_clk;
+		}
+	}
+
+	ipcc->controller.dev = dev;
+	ipcc->controller.txdone_irq = true;
+	ipcc->controller.ops = &rcar_ipcc_ops;
+	ipcc->controller.num_chans = 2;
+	ipcc->controller.chans = devm_kcalloc(dev, ipcc->controller.num_chans,
+						sizeof(*ipcc->controller.chans),
+						GFP_KERNEL);
+
+	ret = devm_mbox_controller_register(dev, &ipcc->controller);
+	if (ret)
+		goto err_clk;
+	
+	platform_set_drvdata(pdev, ipcc);
+
+	return 0;
+
+err_clk:
+	return ret;
+}
+
+static int rcar_ipcc_remove(struct platform_device *pdev)
+{	
+	return 0;
+}
+
+static const struct of_device_id rcar_ipcc_of_match[] = {
+	{ .compatible = "renesas,rcar-ipcc" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rcar_ipcc_of_match);
+
+static struct platform_driver rcar_ipcc_driver = {
+	.driver = {
+		.name = "rcar-ipcc",
+		.of_match_table = rcar_ipcc_of_match,
+	},
+	.probe		= rcar_ipcc_probe,
+	.remove		= rcar_ipcc_remove,
+};
+
+module_platform_driver(rcar_ipcc_driver);
+
+MODULE_AUTHOR("Julien Massot <julien.massot@iot.bzh>");
+MODULE_DESCRIPTION("Renesas RCAR IPCC driver");
+MODULE_LICENSE("GPL v2");
-- 
2.26.2


From a9c6c1d175a02f42dcf1ad02c40bf94680459a2d Mon Sep 17 00:00:00 2001
From: Julien Massot <julien.massot@iot.bzh>
Date: Mon, 26 Oct 2020 10:46:35 +0100
Subject: [PATCH 14/16] add rcar_rproc driver

---
 drivers/remoteproc/Kconfig      |  15 ++
 drivers/remoteproc/Makefile     |   1 +
 drivers/remoteproc/rcar_rproc.c | 392 ++++++++++++++++++++++++++++++++
 3 files changed, 408 insertions(+)
 create mode 100644 drivers/remoteproc/rcar_rproc.c

diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig
index 94afdde4bc9f..a31e44ea2d37 100644
--- a/drivers/remoteproc/Kconfig
+++ b/drivers/remoteproc/Kconfig
@@ -186,6 +186,21 @@ config QCOM_WCNSS_PIL
 	  Say y here to support the Peripheral Image Loader for the Qualcomm
 	  Wireless Connectivity Subsystem.
 
+config RCAR_RPROC
+	tristate "Renesas RCAR remoteproc support"
+	depends on ARCH_RENESAS
+	depends on REMOTEPROC
+	select MAILBOX
+	help
+	  Say y here to support RCAR MCU processors via the
+	  remote processor framework.
+
+	  You want to say y here in order to enable AMP
+	  use-cases to run on your platform (dedicated firmware could be
+	  offloaded to remote MCU processors using this framework).
+
+	  This can be either built-in or a loadable module.
+
 config ST_REMOTEPROC
 	tristate "ST remoteproc support"
 	depends on ARCH_STI
diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile
index 00f09e658cb3..b3baab33e612 100644
--- a/drivers/remoteproc/Makefile
+++ b/drivers/remoteproc/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_QCOM_SYSMON)		+= qcom_sysmon.o
 obj-$(CONFIG_QCOM_WCNSS_PIL)		+= qcom_wcnss_pil.o
 qcom_wcnss_pil-y			+= qcom_wcnss.o
 qcom_wcnss_pil-y			+= qcom_wcnss_iris.o
+obj-$(CONFIG_RCAR_RPROC)		+= rcar_rproc.o
 obj-$(CONFIG_ST_REMOTEPROC)		+= st_remoteproc.o
 obj-$(CONFIG_ST_SLIM_REMOTEPROC)	+= st_slim_rproc.o
 obj-$(CONFIG_STM32_RPROC)		+= stm32_rproc.o
diff --git a/drivers/remoteproc/rcar_rproc.c b/drivers/remoteproc/rcar_rproc.c
new file mode 100644
index 000000000000..fb71aaf525f3
--- /dev/null
+++ b/drivers/remoteproc/rcar_rproc.c
@@ -0,0 +1,392 @@
+#include <linux/mailbox_client.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/regmap.h>
+#include <linux/remoteproc.h>
+#include <linux/workqueue.h>
+
+#include "remoteproc_internal.h"
+
+#define RCAR_RX_VQ_ID 0
+#define RSC_TBL_SIZE		1024
+
+struct rcar_syscon {
+	struct regmap *map;
+	u32 reg;
+	u32 mask;
+};
+
+struct rcar_rproc {
+	struct device			*dev;
+	struct rproc			*rproc;
+	struct delayed_work		rproc_work;
+	struct mbox_client              cl;
+	struct mbox_chan		*tx_ch;
+	struct mbox_chan		*rx_ch;
+	struct workqueue_struct         *workqueue;
+	struct work_struct              vq_work;
+	struct rcar_syscon              rsctbl;
+	void __iomem                    *rsc_va;
+};
+
+static void rcar_rproc_vq_work(struct work_struct *work)
+{
+	struct rcar_rproc *priv = container_of(work, struct rcar_rproc, vq_work);
+	struct rproc *rproc = priv->rproc;
+	if (rproc_vq_interrupt(rproc, RCAR_RX_VQ_ID) == IRQ_NONE)
+		dev_dbg(&rproc->dev, "no message found in vq%d\n", RCAR_RX_VQ_ID);
+};
+
+static void rcar_rproc_rx_callback(struct mbox_client *cl, void *msg)
+{
+	struct rproc *rproc = dev_get_drvdata(cl->dev);
+	struct rcar_rproc *priv = rproc->priv;
+
+	queue_work(priv->workqueue, &priv->vq_work);
+}
+
+static void rcar_rproc_free_mbox(struct rproc *rproc)
+{
+	struct rcar_rproc *priv = rproc->priv;
+
+	if (priv->tx_ch) {
+		mbox_free_channel(priv->tx_ch);
+		priv->tx_ch = NULL;
+	}
+
+	if (priv->rx_ch) {
+		mbox_free_channel(priv->rx_ch);
+		priv->rx_ch = NULL;
+	}
+}
+
+static int rcar_rproc_request_mbox(struct rproc *rproc)
+{
+	struct rcar_rproc *priv = rproc->priv;
+	struct device *dev = &rproc->dev;
+	struct mbox_client *cl;
+	int ret = 0;
+
+	cl = &priv->cl;
+	cl->dev = dev->parent;
+	cl->tx_block = true;
+	cl->tx_tout = 500;
+	cl->knows_txdone = false;
+	cl->rx_callback = rcar_rproc_rx_callback;
+
+	priv->tx_ch = mbox_request_channel_byname(cl, "tx");
+	if (IS_ERR(priv->tx_ch)) {
+		if (PTR_ERR(priv->tx_ch) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		ret = PTR_ERR(priv->tx_ch);
+		dev_dbg(cl->dev, "failed to request mbox tx chan, ret %d\n",
+			ret);
+		goto err_out;
+	}
+
+	priv->rx_ch = mbox_request_channel_byname(cl, "rx");
+	if (IS_ERR(priv->rx_ch)) {
+		if (PTR_ERR(priv->rx_ch) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		ret = PTR_ERR(priv->rx_ch);
+		dev_dbg(cl->dev, "failed to request mbox tx chan, ret %d\n",
+			ret);
+		goto err_out;
+	}
+	INIT_WORK(&priv->vq_work, rcar_rproc_vq_work);
+
+	return ret;
+
+err_out:
+	if (!IS_ERR(priv->tx_ch))
+		mbox_free_channel(priv->tx_ch);
+	if (!IS_ERR(priv->rx_ch))
+		mbox_free_channel(priv->rx_ch);
+
+	return ret;
+}
+
+static void rcar_rproc_kick(struct rproc *rproc, int vqid)
+{
+	struct rcar_rproc *priv = rproc->priv;
+	int err;
+
+	if (!priv->tx_ch)
+		return;
+	err = mbox_send_message(priv->tx_ch, (void *)&vqid);
+	if (err < 0)
+		dev_err(&rproc->dev, "%s: failed (err:%d)\n",
+			__func__, err);
+	return;
+}
+
+static int rcar_rproc_attach(struct rproc *rproc)
+{
+	return 0;
+}
+
+static struct rproc_ops rcar_rproc_ops = {
+	.attach		= rcar_rproc_attach,
+	.kick		= rcar_rproc_kick,
+};
+
+static int rcar_rproc_pa_to_da(struct rproc *rproc, phys_addr_t pa, u64 *da)
+{
+	/* On RCAR da = pa right ? */
+	*da = pa;
+	return 0;
+};
+
+static int rcar_rproc_da_to_pa(struct rproc *rproc, u64 da, phys_addr_t *pa)
+{
+	/* On RCAR pa = da right ? */
+	*pa = da;
+	return 0;
+};
+
+static int rcar_rproc_mem_alloc(struct rproc *rproc,
+				 struct rproc_mem_entry *mem)
+{
+	struct device *dev = rproc->dev.parent;
+	void *va;
+
+	va = ioremap_wc(mem->dma, mem->len);
+	if (IS_ERR_OR_NULL(va)) {
+		dev_err(dev, "Unable to map memory region: %pa+%lx\n",
+			&mem->dma, mem->len);
+		return -ENOMEM;
+	}
+
+	/* Update memory entry va */
+	mem->va = va;
+
+	return 0;
+}
+
+static int rcar_rproc_mem_release(struct rproc *rproc,
+				   struct rproc_mem_entry *mem)
+{
+	dev_dbg(rproc->dev.parent, "unmap memory: %pa\n", &mem->dma);
+	iounmap(mem->va);
+
+	return 0;
+}
+
+static int rcar_rproc_parse_memory_regions(struct rproc *rproc)
+{
+	struct device *dev = rproc->dev.parent;
+	struct device_node *np = dev->of_node;
+	struct of_phandle_iterator it;
+	struct rproc_mem_entry *mem;
+	struct reserved_mem *rmem;
+	u64 da;
+
+	/* Register associated reserved memory regions */
+	of_phandle_iterator_init(&it, np, "memory-region", NULL, 0);
+	while (of_phandle_iterator_next(&it) == 0) {
+
+		rmem = of_reserved_mem_lookup(it.node);
+		if (!rmem) {
+			dev_err(dev, "unable to acquire memory-region\n");
+			return -EINVAL;
+		}
+
+		if (rcar_rproc_pa_to_da(rproc, rmem->base, &da) < 0) {
+			dev_err(dev, "memory region not valid %pa\n",
+				&rmem->base);
+			return -EINVAL;
+		}
+
+		mem = rproc_mem_entry_init(dev, NULL,
+					   (dma_addr_t)rmem->base,
+					   rmem->size, da,
+					   rcar_rproc_mem_alloc,
+					   rcar_rproc_mem_release,
+					   it.node->name);
+
+		if (!mem)
+			return -ENOMEM;
+
+		rproc_add_carveout(rproc, mem);
+	}
+
+	return 0;
+};
+
+static int rcar_rproc_get_syscon(struct device_node *np, const char *prop,
+				  struct rcar_syscon *syscon)
+{
+	int err = 0;
+	syscon->map = syscon_regmap_lookup_by_phandle(np, prop);
+	if (IS_ERR(syscon->map)) {
+		err = -EPROBE_DEFER;
+		syscon->map = NULL;
+		goto out;
+	}
+
+	err = of_property_read_u32_index(np, prop, 1, &syscon->reg);
+	if (err)
+		goto out;
+
+	err = of_property_read_u32_index(np, prop, 2, &syscon->mask);
+
+out:
+	return err;
+}
+
+/*
+ * Remoteproc is supposed to fill in the resource table address in the syscon register.
+ */
+static int rcar_rproc_get_loaded_rsc_table(struct platform_device *pdev,
+					struct rproc *rproc, struct rcar_rproc *priv)
+{
+	struct device *dev = &pdev->dev;
+	phys_addr_t rsc_pa;
+	u32 rsc_da;
+	int err;
+
+	/* See if we can get the resource table */
+	err = rcar_rproc_get_syscon(dev->of_node, "rcar,syscfg-rsc-tbl",
+				     &priv->rsctbl);
+	if (err) {
+		/* no rsc table syscon */
+		dev_warn(dev, "rsc tbl syscon not supported\n");
+		return err;
+	}
+
+	err = regmap_read(priv->rsctbl.map, priv->rsctbl.reg, &rsc_da);
+	if (err) {
+		dev_err(dev, "failed to read rsc tbl addr\n");
+		return err;
+	}
+
+	if (!rsc_da) {
+		/* no rsc table */
+		dev_err(dev, "Ressource table empty does device has booted yet ?");
+		return -ENOENT;
+	}
+
+	err = rcar_rproc_da_to_pa(rproc, rsc_da, &rsc_pa);
+	if (err)
+		return err;
+	/*FIXME: need to unmap */
+	priv->rsc_va = ioremap_wc(rsc_pa, RSC_TBL_SIZE);
+	if (IS_ERR_OR_NULL(priv->rsc_va)) {
+		dev_err(dev, "Unable to map memory region: %pa+%x\n",
+			&rsc_pa, RSC_TBL_SIZE);
+		priv->rsc_va = NULL;
+		return -ENOMEM;
+	}
+
+	/*
+	 * The resource table is already loaded in device memory, no need
+	 * to work with a cached table.
+	 */
+	rproc->cached_table = NULL;
+	/* Assuming the resource table fits in 1kB is fair */
+	rproc->table_sz = RSC_TBL_SIZE;
+	rproc->table_ptr = (struct resource_table *)priv->rsc_va;
+
+	return 0;
+};
+
+static int rcar_rproc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct rcar_rproc *priv;
+	struct rproc *rproc;
+	int ret;
+
+	rproc = rproc_alloc(dev, np->name, &rcar_rproc_ops,
+			    NULL, sizeof(*priv));
+
+	if (!rproc)
+		return -ENOMEM;
+
+	priv = rproc->priv;
+	priv->rproc = rproc;
+	priv->dev = dev;
+
+	dev_set_drvdata(dev, rproc);
+
+	ret = rcar_rproc_get_loaded_rsc_table(pdev, rproc, priv);
+	if (ret)
+		goto free_rproc;
+
+	ret = rcar_rproc_parse_memory_regions(rproc);
+	if (ret)
+		goto free_rproc;
+
+	/* Assume rproc is loaded by another component e.g u-boot */
+	rproc->state = RPROC_DETACHED;
+
+	priv->workqueue = create_workqueue(dev_name(dev));
+	if (!priv->workqueue) {
+		dev_err(dev, "cannot create workqueue\n");
+		ret = -ENOMEM;
+		goto free_resources;
+	}
+
+	ret = rcar_rproc_request_mbox(rproc);
+	if (ret)
+		goto free_wkq;
+
+	ret = rproc_add(rproc);
+	if (ret) {
+		dev_err(dev, "rproc_add failed\n");
+		goto free_mb;
+	}
+
+	return 0;
+
+free_mb:
+	rcar_rproc_free_mbox(rproc);
+free_wkq:
+	destroy_workqueue(priv->workqueue);
+free_resources:
+	rproc_resource_cleanup(rproc);
+free_rproc:
+	rproc_free(rproc);
+
+	return ret;
+}
+
+static int rcar_rproc_remove(struct platform_device *pdev)
+{
+	struct rproc *rproc = platform_get_drvdata(pdev);
+	struct rcar_rproc *priv = rproc->priv;
+
+	rproc_del(rproc);
+	rcar_rproc_free_mbox(rproc);
+	destroy_workqueue(priv->workqueue);
+	if (priv->rsc_va)
+		iounmap(priv->rsc_va);
+	rproc_free(rproc);
+
+	return 0;
+}
+
+static const struct of_device_id rcar_rproc_of_match[] = {
+	{ .compatible = "renesas,rcar-cr7" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, rcar_rproc_of_match);
+
+static struct platform_driver rcar_rproc_driver = {
+	.probe = rcar_rproc_probe,
+	.remove = rcar_rproc_remove,
+	.driver = {
+		.name = "rcar-rproc",
+		.of_match_table = rcar_rproc_of_match,
+	},
+};
+
+module_platform_driver(rcar_rproc_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Renesas Gen3 RCAR remote processor control driver");
+MODULE_AUTHOR("Julien Massot <julien.massot@iot.bzh>");
-- 
2.26.2


From 37b106a7a686e20b8c0cff5fcb6eb33069d1a35f Mon Sep 17 00:00:00 2001
From: Julien Massot <julien.massot@iot.bzh>
Date: Mon, 26 Oct 2020 16:15:58 +0100
Subject: [PATCH 15/16] ebisu-4d.dts: add definition for Cortex-R7 remoteproc

Add Mailbox and remoteproc, also add the shm area for rpmsg.

Note that this patch disable the support of mfis-lock and mfis-as,
since register area are conflicting.
---
 .../boot/dts/renesas/r8a77990-ebisu-4d.dts    | 32 ++++++++++++++++
 arch/arm64/boot/dts/renesas/r8a77990.dtsi     | 37 ++++++++++++-------
 2 files changed, 56 insertions(+), 13 deletions(-)

diff --git a/arch/arm64/boot/dts/renesas/r8a77990-ebisu-4d.dts b/arch/arm64/boot/dts/renesas/r8a77990-ebisu-4d.dts
index 1c19504c672b..1af92c67d5d4 100644
--- a/arch/arm64/boot/dts/renesas/r8a77990-ebisu-4d.dts
+++ b/arch/arm64/boot/dts/renesas/r8a77990-ebisu-4d.dts
@@ -19,6 +19,30 @@
 	};
 
 	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		cr7_ram: cr7_ram@0x40040000 {
+			no-map;
+			reg = <0x0 0x40040000 0x0 0x1fc0000>;
+		};
+
+		vdev0vring0: vdev0vring0@42000000 {
+			no-map;
+			reg = <0x0 0x42000000 0x0 0x1000>;
+		};
+
+		vdev0vring1: vdev0vring1@42010000 {
+			no-map;
+			reg = <0x0 0x42010000 0x0 0x1000>;
+		};
+
+		vdev0buffer: vdev0buffer@42020000 {
+			no-map;
+			reg = <0x0 0x42020000 0x0 0x4000>;
+		};
+
 		/* device specific region for Lossy Decompression */
 		lossy_decompress: linux,lossy_decompress@54000000 {
 			no-map;
@@ -35,3 +59,11 @@
 	/* Map all possible DDR as inbound ranges */
 	dma-ranges = <0x42000000 0 0x40000000 0 0x40000000 0 0x80000000>;
 };
+
+&cr7_rproc {
+	memory-region = <&cr7_ram>, <&vdev0vring0>, <&vdev0vring1>, <&vdev0buffer>;
+	mboxes = <&mfis 0>, <&mfis 1>;
+	mbox-names = "tx", "rx";
+	rcar,syscfg-rsc-tbl = <&mfisarembr 0x0 0xFFFFFFFF>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/renesas/r8a77990.dtsi b/arch/arm64/boot/dts/renesas/r8a77990.dtsi
index 98c6be89e7e3..2bd7010be060 100755
--- a/arch/arm64/boot/dts/renesas/r8a77990.dtsi
+++ b/arch/arm64/boot/dts/renesas/r8a77990.dtsi
@@ -202,19 +202,11 @@
 		#size-cells = <2>;
 		ranges;
 
-		mfis: mfis@e6260000 {
-			compatible = "renesas,mfis-lock-r8a77990",
-				     "renesas,mfis-lock";
-			reg = <0 0xe6260000 0 0x1000>;
-			#hwlock-cells = <1>;
-
-			mfis_as: mfis-as {
-				compatible = "renesas,mfis-as-r8a77990",
-					     "renesas,mfis-as";
-				interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>;
-				interrupt-names = "eicr0";
-				renesas,mfis-ch = <0>;
-			};
+		cr7_rproc: cr7@40040000 {
+			compatible = "renesas,rcar-cr7";
+			power-domains = <&sysc R8A77990_PD_CR7>;
+			resets = <&cpg 222>;
+			status = "disabled";
 		};
 
 		rwdt: watchdog@e6020000 {
@@ -470,6 +462,25 @@
 			power-domains = <&sysc R8A77990_PD_ALWAYS_ON>;
 		};
 
+		mfis: mailbox@e6260400 {
+			compatible = "renesas,rcar-ipcc";
+			#mbox-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0xe6260400 0 0x10>;
+			interrupts =
+				<GIC_SPI 224 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 225 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "tx", "rx";
+			clocks = <&cpg CPG_MOD 213>;
+			resets = <&cpg 213>;
+		};
+
+		mfisarembr: mfisarembr@e6260460{
+			compatible = "simple-bus", "syscon", "simple-mfd";
+			reg = <0 0xe6260460 0 0x20>;
+		};
+
 		i2c0: i2c@e6500000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
-- 
2.26.2


From 151bb343e6a56b201cfd2d5b49e5a3e184c531f7 Mon Sep 17 00:00:00 2001
From: Julien Massot <julien.massot@iot.bzh>
Date: Tue, 27 Oct 2020 18:02:58 +0100
Subject: [PATCH 16/16] h3ulcb.dts: add definition for Cortex-R7 remoteproc

Add Mailbox and remoteproc, also add the shm area for rpmsg.

Note that this patch disable the support of mfis-lock and mfis-as,
since register area are conflicting.
---
 .../arm64/boot/dts/renesas/r8a7795-h3ulcb.dts | 28 ++++++++++++++
 arch/arm64/boot/dts/renesas/r8a7795.dtsi      | 38 ++++++++++++-------
 2 files changed, 53 insertions(+), 13 deletions(-)

diff --git a/arch/arm64/boot/dts/renesas/r8a7795-h3ulcb.dts b/arch/arm64/boot/dts/renesas/r8a7795-h3ulcb.dts
index 87132c0fe4b4..c02560e044e5 100644
--- a/arch/arm64/boot/dts/renesas/r8a7795-h3ulcb.dts
+++ b/arch/arm64/boot/dts/renesas/r8a7795-h3ulcb.dts
@@ -40,6 +40,26 @@
 		#size-cells = <2>;
 		ranges;
 
+		cr7_ram: cr7_ram@0x40040000 {
+			no-map;
+			reg = <0x0 0x40040000 0x0 0x1fc0000>;
+		};
+
+		vdev0vring0: vdev0vring0@42000000 {
+			no-map;
+			reg = <0x0 0x42000000 0x0 0x1000>;
+		};
+
+		vdev0vring1: vdev0vring1@42010000 {
+			no-map;
+			reg = <0x0 0x42010000 0x0 0x1000>;
+		};
+
+		vdev0buffer: vdev0buffer@42020000 {
+			no-map;
+			reg = <0x0 0x42020000 0x0 0x4000>;
+		};
+
 		/* device specific region for Lossy Decompression */
 		lossy_decompress: linux,lossy_decompress@54000000 {
 			no-map;
@@ -118,3 +138,11 @@
 &vspi1 {
 	status = "okay";
 };
+
+&cr7_rproc {
+	memory-region = <&cr7_ram>, <&vdev0vring0>, <&vdev0vring1>, <&vdev0buffer>;
+	mboxes = <&mfis 0>, <&mfis 1>;
+	mbox-names = "tx", "rx";
+	rcar,syscfg-rsc-tbl = <&mfisarembr 0x0 0xFFFFFFFF>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/renesas/r8a7795.dtsi b/arch/arm64/boot/dts/renesas/r8a7795.dtsi
index cfed8e110f01..89a6abc44a1d 100755
--- a/arch/arm64/boot/dts/renesas/r8a7795.dtsi
+++ b/arch/arm64/boot/dts/renesas/r8a7795.dtsi
@@ -807,19 +807,11 @@
 		#size-cells = <2>;
 		ranges;
 
-		mfis: mfis@e6260000 {
-			compatible = "renesas,mfis-lock-r8a7795",
-				     "renesas,mfis-lock";
-			reg = <0 0xe6260000 0 0x1000>;
-			#hwlock-cells = <1>;
-
-			mfis_as: mfis-as {
-				compatible = "renesas,mfis-as-r8a7795",
-					     "renesas,mfis-as";
-				interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>;
-				interrupt-names = "eicr0";
-				renesas,mfis-ch = <0>;
-			};
+		cr7_rproc: cr7@40040000 {
+			compatible = "renesas,rcar-cr7";
+			power-domains = <&sysc R8A7795_PD_CR7>;
+			resets = <&cpg 222>;
+			status = "disabled";
 		};
 
 		rwdt: watchdog@e6020000 {
@@ -1081,6 +1073,26 @@
 			power-domains = <&sysc R8A7795_PD_ALWAYS_ON>;
 		};
 
+		mfis: mailbox@e6260400 {
+			compatible = "renesas,rcar-ipcc";
+			#mbox-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0xe6260400 0 0x10>;
+			interrupts =
+				<GIC_SPI 224 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 225 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "tx", "rx";
+			clocks = <&cpg  CPG_MOD 213>;
+			power-domains = <&sysc R8A7795_PD_ALWAYS_ON>;
+			resets = <&cpg 213>;
+		};
+
+		mfisarembr: mfisarembr@e6260460{
+			compatible = "simple-bus", "syscon", "simple-mfd";
+			reg = <0 0xe6260460 0 0x20>;
+		};
+
 		i2c0: i2c@e6500000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
-- 
2.26.2

From c814100afde5e4ac2335de0be17bdc29c955c184 Mon Sep 17 00:00:00 2001
From: Ronan Le Martret <ronan.lemartret@iot.bzh>
Date: Thu, 26 Nov 2020 14:03:29 +0000
Subject: [PATCH] m3ulcb.dts: add definition for Cortex-R7 remoteproc

Add Mailbox and remoteproc, also add the shm area for rpmsg.

Note that this patch disable the support of mfis-lock and mfis-as,
since register area are conflicting.

Signed-off-by: Ronan Le Martret <ronan.lemartret@iot.bzh>
---
 .../arm64/boot/dts/renesas/r8a7796-m3ulcb.dts | 28 ++++++++++++++
 arch/arm64/boot/dts/renesas/r8a7796.dtsi      | 38 ++++++++++++-------
 2 files changed, 53 insertions(+), 13 deletions(-)

diff --git a/arch/arm64/boot/dts/renesas/r8a7796-m3ulcb.dts b/arch/arm64/boot/dts/renesas/r8a7796-m3ulcb.dts
index 392b7302ccce..72ce4d6b63af 100644
--- a/arch/arm64/boot/dts/renesas/r8a7796-m3ulcb.dts
+++ b/arch/arm64/boot/dts/renesas/r8a7796-m3ulcb.dts
@@ -35,6 +35,26 @@
 		#size-cells = <2>;
 		ranges;
 
+		cr7_ram: cr7_ram@0x40040000 {
+			no-map;
+			reg = <0x0 0x40040000 0x0 0x1fc0000>;
+		};
+
+		vdev0vring0: vdev0vring0@42000000 {
+			no-map;
+			reg = <0x0 0x42000000 0x0 0x1000>;
+		};
+
+		vdev0vring1: vdev0vring1@42010000 {
+			no-map;
+			reg = <0x0 0x42010000 0x0 0x1000>;
+		};
+
+		vdev0buffer: vdev0buffer@42020000 {
+			no-map;
+			reg = <0x0 0x42020000 0x0 0x4000>;
+		};
+
 		/* device specific region for Lossy Decompression */
 		lossy_decompress: linux,lossy_decompress@54000000 {
 			no-map;
@@ -154,3 +174,11 @@
 &vspi0 {
 	status = "okay";
 };
+
+&cr7_rproc {
+	memory-region = <&cr7_ram>, <&vdev0vring0>, <&vdev0vring1>, <&vdev0buffer>;
+	mboxes = <&mfis 0>, <&mfis 1>;
+	mbox-names = "tx", "rx";
+	rcar,syscfg-rsc-tbl = <&mfisarembr 0x0 0xFFFFFFFF>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/renesas/r8a7796.dtsi b/arch/arm64/boot/dts/renesas/r8a7796.dtsi
index 46bbba40ef84..472b94be382e 100755
--- a/arch/arm64/boot/dts/renesas/r8a7796.dtsi
+++ b/arch/arm64/boot/dts/renesas/r8a7796.dtsi
@@ -811,19 +811,11 @@
 		#size-cells = <2>;
 		ranges;
 
-		mfis: mfis@e6260000 {
-			compatible = "renesas,mfis-lock-r8a7796",
-				     "renesas,mfis-lock";
-			reg = <0 0xe6260000 0 0x1000>;
-			#hwlock-cells = <1>;
-
-			mfis_as: mfis-as {
-				compatible = "renesas,mfis-as-r8a7796",
-					     "renesas,mfis-as";
-				interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>;
-				interrupt-names = "eicr0";
-				renesas,mfis-ch = <0>;
-			};
+		cr7_rproc: cr7@40040000 {
+			compatible = "renesas,rcar-cr7";
+			power-domains = <&sysc R8A7796_PD_CR7>;
+			resets = <&cpg 222>;
+			status = "disabled";
 		};
 
 		rwdt: watchdog@e6020000 {
@@ -1086,6 +1078,26 @@
 			power-domains = <&sysc R8A7796_PD_ALWAYS_ON>;
 		};
 
+		mfis: mailbox@e6260400 {
+			compatible = "renesas,rcar-ipcc";
+			#mbox-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0xe6260400 0 0x10>;
+			interrupts =
+				<GIC_SPI 224 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 225 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "tx", "rx";
+			clocks = <&cpg  CPG_MOD 213>;
+			power-domains = <&sysc R8A7796_PD_ALWAYS_ON>;
+			resets = <&cpg 213>;
+		};
+
+		mfisarembr: mfisarembr@e6260460{
+			compatible = "simple-bus", "syscon", "simple-mfd";
+			reg = <0 0xe6260460 0 0x20>;
+		};
+
 		i2c0: i2c@e6500000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
-- 
2.28.0

From 322b0730f5f5aaae4b70e403572f1214957ca3fa Mon Sep 17 00:00:00 2001
From: Ronan Le Martret <ronan.lemartret@iot.bzh>
Date: Thu, 26 Nov 2020 15:09:06 +0000
Subject: [PATCH] clk: add clock for MFIS registers

Fix for M3ulcb

Signed-off-by: Ronan Le Martret <ronan.lemartret@iot.bzh>
---
 drivers/clk/renesas/r8a7796-cpg-mssr.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/clk/renesas/r8a7796-cpg-mssr.c b/drivers/clk/renesas/r8a7796-cpg-mssr.c
index b07354da223d..dc5fd00d0535 100644
--- a/drivers/clk/renesas/r8a7796-cpg-mssr.c
+++ b/drivers/clk/renesas/r8a7796-cpg-mssr.c
@@ -134,6 +134,7 @@ static struct mssr_mod_clk r8a7796_mod_clks[] __initdata = {
 	DEF_MOD("msiof2",		 209,	R8A7796_CLK_MSO),
 	DEF_MOD("msiof1",		 210,	R8A7796_CLK_MSO),
 	DEF_MOD("msiof0",		 211,	R8A7796_CLK_MSO),
+	DEF_MOD("mfis",		         213,	R8A7796_CLK_MSO),
 	DEF_MOD("sys-dmac2",		 217,	R8A7796_CLK_S3D1),
 	DEF_MOD("sys-dmac1",		 218,	R8A7796_CLK_S3D1),
 	DEF_MOD("sys-dmac0",		 219,	R8A7796_CLK_S0D3),
-- 
2.28.0

From 8bdb6841fbd2bc6047ceaa0ee234405ba5a85fb3 Mon Sep 17 00:00:00 2001
From: Julien Massot <julien.massot@iot.bzh>
Date: Thu, 3 Dec 2020 17:37:27 +0100
Subject: [PATCH 1/2] soc: renesas: rcar-rst: Add support for Cortex R7

Allow to set a boot address for the Cortex R7 processor.

Signed-off-by: Julien Massot <julien.massot@iot.bzh>
---
 drivers/soc/renesas/rcar-rst.c       | 23 ++++++++++++++++++++++-
 include/linux/soc/renesas/rcar-rst.h |  2 ++
 2 files changed, 24 insertions(+), 1 deletion(-)

diff --git a/drivers/soc/renesas/rcar-rst.c b/drivers/soc/renesas/rcar-rst.c
index d183c381e8db..32c2edb200ac 100644
--- a/drivers/soc/renesas/rcar-rst.c
+++ b/drivers/soc/renesas/rcar-rst.c
@@ -12,6 +12,8 @@
 
 #define WDTRSTCR_RESET		0xA55A0002
 #define WDTRSTCR		0x0054
+#define CR7BAR                  0x0070
+#define CR7BAREN                BIT(4)
 
 static int rcar_rst_enable_wdt_reset(void __iomem *base)
 {
@@ -66,7 +68,7 @@ static const struct of_device_id rcar_rst_matches[] __initconst = {
 	{ /* sentinel */ }
 };
 
-static void __iomem *rcar_rst_base __initdata;
+static void __iomem *rcar_rst_base;
 static u32 saved_mode __initdata;
 
 static int __init rcar_rst_init(void)
@@ -120,3 +122,22 @@ int __init rcar_rst_read_mode_pins(u32 *mode)
 	*mode = saved_mode;
 	return 0;
 }
+
+int rcar_rst_set_rproc_boot_addr(u32 boot_addr)
+{
+	if (!rcar_rst_base) {
+			return -EIO;
+	}
+
+	if (boot_addr % SZ_4K) {
+		pr_debug("Invalid boot address for remote processor,"
+		       "should be aligned on 4k got %x\n", boot_addr);
+		pr_debug("rounding down to 4k\n");
+		boot_addr -= boot_addr % SZ_4K;
+	}
+
+	boot_addr |= CR7BAREN;
+	iowrite32(boot_addr, rcar_rst_base + CR7BAR);
+
+	return 0;
+}
diff --git a/include/linux/soc/renesas/rcar-rst.h b/include/linux/soc/renesas/rcar-rst.h
index 7899a5b8c247..7c97c2c4bba6 100644
--- a/include/linux/soc/renesas/rcar-rst.h
+++ b/include/linux/soc/renesas/rcar-rst.h
@@ -4,8 +4,10 @@
 
 #ifdef CONFIG_RST_RCAR
 int rcar_rst_read_mode_pins(u32 *mode);
+int rcar_rst_set_rproc_boot_addr(u32 boot_addr);
 #else
 static inline int rcar_rst_read_mode_pins(u32 *mode) { return -ENODEV; }
+static inline int rcar_rst_set_rproc_boot_addr(u32 boot_addr) { return -ENODEV; }
 #endif
 
 #endif /* __LINUX_SOC_RENESAS_RCAR_RST_H__ */
-- 
2.29.2

From 1cc1ec8f7cc7761de47add01a355efd9dfed6725 Mon Sep 17 00:00:00 2001
From: Julien Massot <julien.massot@iot.bzh>
Date: Tue, 8 Dec 2020 10:34:51 +0100
Subject: [PATCH 2/2] remoteproc: rcar_rproc: add support for starting the
 rproc

In previous version this driver was only able to attach to an
already started remoteproc.

Starting the embbedded Cortex-r7 boils down to 4 steps:
- powering up the remote processor
- loading the firmware
- setting cr7 boot address (CR7BAR)
- deassert the reset line

Signed-off-by: Julien Massot <julien.massot@iot.bzh>
---
 drivers/remoteproc/Kconfig      |   1 +
 drivers/remoteproc/rcar_rproc.c | 108 ++++++++++++++++++++++++++++----
 drivers/soc/renesas/rcar-rst.c  |   1 +
 3 files changed, 98 insertions(+), 12 deletions(-)

diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig
index a31e44ea2d37..fbd813419051 100644
--- a/drivers/remoteproc/Kconfig
+++ b/drivers/remoteproc/Kconfig
@@ -190,6 +190,7 @@ config RCAR_RPROC
 	tristate "Renesas RCAR remoteproc support"
 	depends on ARCH_RENESAS
 	depends on REMOTEPROC
+	depends on RST_RCAR
 	select MAILBOX
 	help
 	  Say y here to support RCAR MCU processors via the
diff --git a/drivers/remoteproc/rcar_rproc.c b/drivers/remoteproc/rcar_rproc.c
index fb71aaf525f3..54634f4f1481 100644
--- a/drivers/remoteproc/rcar_rproc.c
+++ b/drivers/remoteproc/rcar_rproc.c
@@ -1,10 +1,14 @@
+#include <linux/limits.h>
 #include <linux/mailbox_client.h>
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
 #include <linux/of_reserved_mem.h>
+#include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/remoteproc.h>
+#include <linux/reset.h>
+#include <linux/soc/renesas/rcar-rst.h>
 #include <linux/workqueue.h>
 
 #include "remoteproc_internal.h"
@@ -25,6 +29,7 @@ struct rcar_rproc {
 	struct mbox_client              cl;
 	struct mbox_chan		*tx_ch;
 	struct mbox_chan		*rx_ch;
+	struct reset_control            *rst;
 	struct workqueue_struct         *workqueue;
 	struct work_struct              vq_work;
 	struct rcar_syscon              rsctbl;
@@ -127,10 +132,44 @@ static int rcar_rproc_attach(struct rproc *rproc)
 	return 0;
 }
 
-static struct rproc_ops rcar_rproc_ops = {
-	.attach		= rcar_rproc_attach,
-	.kick		= rcar_rproc_kick,
-};
+static int rcar_rproc_start(struct rproc *rproc)
+{
+	struct rcar_rproc *priv = rproc->priv;
+	int err;
+
+	if (!rproc->bootaddr)
+		return -EINVAL;
+
+	/* RCar remote proc only support boot address on 32 bits */
+	if (rproc->bootaddr > U32_MAX)
+		return -EINVAL;
+
+	err = rcar_rst_set_rproc_boot_addr((u32)rproc->bootaddr);
+	if (err) {
+		dev_err(&rproc->dev, "failed to set rproc boot addr\n");
+		return err;
+	}
+
+	err = reset_control_deassert(priv->rst);
+	if (err) {
+		dev_err(&rproc->dev, "failed to bring out of reset\n");
+	}
+
+	return err;
+}
+
+static int rcar_rproc_stop(struct rproc *rproc)
+{
+	struct rcar_rproc *priv = rproc->priv;
+	int err;
+
+	err = reset_control_assert(priv->rst);
+	if (err) {
+		dev_err(&rproc->dev, "failed to put in reset\n");
+	}
+
+	return err;
+}
 
 static int rcar_rproc_pa_to_da(struct rproc *rproc, phys_addr_t pa, u64 *da)
 {
@@ -215,6 +254,38 @@ static int rcar_rproc_parse_memory_regions(struct rproc *rproc)
 	return 0;
 };
 
+static int rcar_rproc_elf_load_rsc_table(struct rproc *rproc,
+					  const struct firmware *fw)
+{
+	if (rproc_elf_load_rsc_table(rproc, fw))
+		dev_info(&rproc->dev, "no resource table found for this firmware\n");
+
+	return 0;
+}
+
+static int rcar_rproc_parse_fw(struct rproc *rproc, const struct firmware *fw)
+{
+	int ret = rcar_rproc_parse_memory_regions(rproc);
+
+	if (ret)
+		return ret;
+
+	return rcar_rproc_elf_load_rsc_table(rproc, fw);
+}
+
+static struct rproc_ops rcar_rproc_ops = {
+	.start		= rcar_rproc_start,
+	.stop		= rcar_rproc_stop,
+	.attach		= rcar_rproc_attach,
+	.kick		= rcar_rproc_kick,
+	.load		= rproc_elf_load_segments,
+	.parse_fw	= rcar_rproc_parse_fw,
+	.find_loaded_rsc_table = rproc_elf_find_loaded_rsc_table,
+	.sanity_check	= rproc_elf_sanity_check,
+	.get_boot_addr	= rproc_elf_get_boot_addr,
+
+};
+
 static int rcar_rproc_get_syscon(struct device_node *np, const char *prop,
 				  struct rcar_syscon *syscon)
 {
@@ -310,18 +381,29 @@ static int rcar_rproc_probe(struct platform_device *pdev)
 	priv->rproc = rproc;
 	priv->dev = dev;
 
-	dev_set_drvdata(dev, rproc);
-
-	ret = rcar_rproc_get_loaded_rsc_table(pdev, rproc, priv);
-	if (ret)
+	priv->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(priv->rst)) {
+		ret = PTR_ERR(priv->rst);
+		dev_err(dev, "failed to get rproc reset\n");
 		goto free_rproc;
+	}
 
-	ret = rcar_rproc_parse_memory_regions(rproc);
-	if (ret)
+	pm_runtime_enable(priv->dev);
+	ret = pm_runtime_get_sync(priv->dev);
+	if (ret) {
+		dev_err(&rproc->dev, "failed to power up\n");
 		goto free_rproc;
+	}
 
-	/* Assume rproc is loaded by another component e.g u-boot */
-	rproc->state = RPROC_DETACHED;
+	dev_set_drvdata(dev, rproc);
+
+	ret = rcar_rproc_get_loaded_rsc_table(pdev, rproc, priv);
+	if (!ret) {
+		rproc->state = RPROC_DETACHED;
+		ret = rcar_rproc_parse_memory_regions(rproc);
+		if (ret)
+			goto free_rproc;
+	}
 
 	priv->workqueue = create_workqueue(dev_name(dev));
 	if (!priv->workqueue) {
@@ -348,6 +430,7 @@ static int rcar_rproc_probe(struct platform_device *pdev)
 	destroy_workqueue(priv->workqueue);
 free_resources:
 	rproc_resource_cleanup(rproc);
+	pm_runtime_disable(priv->dev);
 free_rproc:
 	rproc_free(rproc);
 
@@ -362,6 +445,7 @@ static int rcar_rproc_remove(struct platform_device *pdev)
 	rproc_del(rproc);
 	rcar_rproc_free_mbox(rproc);
 	destroy_workqueue(priv->workqueue);
+	pm_runtime_disable(priv->dev);
 	if (priv->rsc_va)
 		iounmap(priv->rsc_va);
 	rproc_free(rproc);
diff --git a/drivers/soc/renesas/rcar-rst.c b/drivers/soc/renesas/rcar-rst.c
index 32c2edb200ac..f6b98a521c87 100644
--- a/drivers/soc/renesas/rcar-rst.c
+++ b/drivers/soc/renesas/rcar-rst.c
@@ -141,3 +141,4 @@ int rcar_rst_set_rproc_boot_addr(u32 boot_addr)
 
 	return 0;
 }
+EXPORT_SYMBOL(rcar_rst_set_rproc_boot_addr);
-- 
2.29.2

From 80eb49f52b6313319cf65865707e990adb3c2c36 Mon Sep 17 00:00:00 2001
From: Julien Massot <julien.massot@iot.bzh>
Date: Tue, 15 Dec 2020 11:43:03 +0100
Subject: [PATCH] remoteproc: rcar: disable auto_boot

Since remoteproc try to fetch a firmware before filesytem is there,
the request hang for few second a delay the possibility to request a
start manually.

Let the user the choice to start the remote processor.
---
 drivers/remoteproc/rcar_rproc.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/remoteproc/rcar_rproc.c b/drivers/remoteproc/rcar_rproc.c
index 54634f4f1481..4d745278049e 100644
--- a/drivers/remoteproc/rcar_rproc.c
+++ b/drivers/remoteproc/rcar_rproc.c
@@ -403,6 +403,9 @@ static int rcar_rproc_probe(struct platform_device *pdev)
 		ret = rcar_rproc_parse_memory_regions(rproc);
 		if (ret)
 			goto free_rproc;
+	} else {
+		/* Manually start the rproc */
+		rproc->auto_boot = false;
 	}
 
 	priv->workqueue = create_workqueue(dev_name(dev));
-- 
2.29.2

